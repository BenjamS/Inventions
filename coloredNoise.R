coloredNoise <- function(n, a, normalize = T, graph = F)
{
# 13 / 02 / 18
# Description: 1/f^a noise generator with free parameter "a."
# Outputs a 1/f^a noise R-by-C matrix.
# By adjusting parameter "a" can generate pink, red,
# white, blue, violet noise, or any gradation in between.
# As "a" is less, the signal is more autocorrelated, less random,
# degenerating ultimately into a sine curve. As "a" is greater,
# the signal is more random, approaching white noise and beyond
# (approaching any signal with fractal dimension of 2)
# NOTE: "a" is closely related to the signal's fractal dimension.
# "a" and fract. dim. are related by the logistic function.
# Envisioned Use: Signal generation to immitate 
# stock charts for example. Or as a "random number
# generator" where it is possible to adjust the balance
# between randomness and autocorrelation (by adjusting "a").
# In other words the user has here a random number generator 
# where the fractal dimension of the number selection 
# can be adjusted.
# Source: This function is adapted from Hristo Zhivomirov's Pink,
# Red, Violet, and Blue Noise Generation functions (written in Matlab)
# https://la.mathworks.com/matlabcentral/fileexchange/42919-pink--red--blue-and-violet-noise-generation-with-matlab-implementation?focused=7825006&tab=function
# All those functions are combined in this single function
# (as well as the gradations in bewtween).
#---------------------------
  # Input:
  # R - number of rows to be returned
# C - number of samples to be returned in each row vector
# a - parameter relating power to frequency.  I.e. the 
# power spectral density is proportional
# to the frequency f by a factor f^(-2*a). In other words,
# the amplitudes are proportional to f^(-a).
# normalize - Normalizes output y if ==1.  Note normalization
# changes the standard deviation of the output.
# Output:
  # y - row vector of noise samples
#-----------------------------
  # Each color of noise is generated by adjusting the 
# parameter "a" as follows:
  # a=-2    red or brown(ian) noise (fractal dim.~1.5 - like stock charts)
  # a=-1  pink noise (fractal dim.~1.85)
  # a=0     white noise (output equivalent to y=randn(1,N) IF normalize==0)
  # a=1   blue noise (fractal dim.~2)
  # a=2     violet noise (fractal dim.~2)
  
  
  # More info on each noise color follows:
    # (taken from Zhivomirov's notes)
       #------------------------------------
       # red noise: Aka brown noise. In terms of power at a 
       # constant bandwidth, red noise falls off at 6 dB per 
       # octave. The power spectral density is inversely 
       # proportional to the frequency by factor 1/(f^2), 
       # i.e. the amplitudes are inversely proportional to 1/f.
       
       # pink noise: Aka "1/f noise." The pink noise setting 
       # generates a sequence of pink (flicker) noise samples. 
       # Pink noise has equal energy in all octaves (or similar 
       # log bundles) of frequency. In terms of power at a 
       # constant bandwidth, pink noise falls off at 3 dB per 
       # octave. The power spectral density is inversely 
       # proportional to the frequency by factor 1/f,
       # i.e. the amplitudes are inversely proportional to 1/sqrt(f).
       
       # blue noise: In terms of power at a constant bandwidth, 
       # blue noise increase in at 3 dB per octave. The power 
       # spectral density is proportional to the frequency by 
       # factor f, i.e. the amplitudes are proportional to sqrt(f).
       
       # violet noise: Aka purple noise. In terms of power at a 
       # constant bandwidth, violet noise increase in at 6 dB per
       # octave. The power spectral density is proportional to the 
       # frequency by factor f^2, i.e. the amplitudes are 
       # proportional to f.
       #================================================
       if(rem(n, 2)){n <- n + 1}
       # generate white noise with sigma = 1, mu = 0
       x <- rnorm(n)
       # FFT
       X <- fft(x)
       # prepare a vector for 1/f multiplication
       NumUniquePts <- n / 2 + 1
       ind_left <- 1:NumUniquePts
       # multiply the left half of the spectrum so the power spectral density
       # is inversely proportional to the frequency by factor f^a, i.e. the
       # amplitudes are inversely proportional to f^(a/2)
       X[ind_left] <- X[ind_left] * ind_left^(a / 2)
       # prepare a right half of the spectrum - a copy of the left one,
       # except the DC component and Nyquist frequency - they are unique
       ind_right <- seq(n / 2, 2, -1)
       X[(NumUniquePts + 1):n] <- Re(X[ind_right]) - 1i * Im(X[ind_right]);
       # IFFT
       y <- ifft(X)
       # prepare output vector y
       y <- Re(y[1:n])
       # normalise?
         if(normalize == T){
           y <- y / max(abs(y))
         }
       if(graph == T){
         xplot <- 1:n
         dfplot <- data.frame(output = y, sequence = xplot)
         gg1 <- ggplot(dfplot, aes(x = output)) + geom_density()
         gg2 <- ggplot(dfplot, aes(x = sequence, y = output)) + geom_line()
         grid.arrange(gg1, gg2, ncol = 1)
       }
       return(y)
}