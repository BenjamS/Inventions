---
title: "Tradeoffs, risk, and optimization of investments across strategic objectives"
author: "Ben Schiek"
date: "July 18, 2019"
output:
  pdf_document:
    toc: true
    toc_depth: 4
    latex_engine: xelatex
mainfont: Calibri Light

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```


## I. Introduction
### I.i Problem background
At the most abstract levels of strategic planning, it is customary for large development agencies and donor organizations to carefully define a manageable number of thematic areas for investment that broadly cover all aspects of development. The 17 Sustainable Development Goals (SDG), for example, are grouped  Persons (poverty reduction and human rights), Environmental Sustainability, Economic Prosperity, Peace, and Alliances ().

* Economic growth

* Economic equality, poverty reduction

* Food and nutritional security

* Environmental protection, conservation, reduced C02 emissions, etc.

* Health


...

### Proposed solution

In this paper, I propose a method to identify and quantify such tradeoffs in the SDG Tracker historical data. I then combine this with methods from financial analysis to determine a donor's optimal allocation of investments across the indicators given the donor's level of risk tolerance.

#### Eigendecomposition of SDG Tracker data

The method for identifying and quantifying tradeoffs is based on the eigendecomposition of the correlation matrix of SDG Tracker data. First, signals are separated from noise using a method developed in the analysis of physical systems (). The components of the retained eigenvectors are then interpreted as the magnitude and direction of the influence (a.k.a. "loading" or "score") of each SDG Tracker over the average movement of the dataset. Loadings with opposite signs indicate a tradeoff, while loadings with the same sign are indicative of synergy.

Beyond tradeoffs, this method is also useful for identifying just a few key crosscutting tendencies that are broadly characteristic of the entire dataset. In other words, the loadings on each eigenvector tend to be thematically organized, such that each eigenvector captures a particular aspect of the overall evolution of the system. This effectively reduces the problem of making sense of several dozen complexly interacting indicators to the more mangeable problem of making sense of just a few crosscutting trends.

#### Risk adjusted portfolio optimization

The identification of tradeoffs and key crosscutting trends is useful in and of itself for stimulating and orienting high level policy discussion. However, longstanding methods used in the analogous decisionmaking context of finance are motivation to aim for more. In particular, a variant of Minimum Variance (MV) analysis can be applied to determine the optimal allocation of a budget across the---potentially several dozen---SDG indicators, given a certain risk tolerance.

It is worth taking a moment to emphasize that this goes far beyond the mere "priority setting", with which many donors, development agencies, and research for development (R4D) institutions may be familiar. The method proposed here, adapted from finance, determines, _precisely_, the portion of the donor's/development agency's/R4D research institution's budget that must be allocated in order to maximize net benefit, given a certain risk tolerance specified by the donor. (The budget can be a budget in the literal sense, or an "attention" or "enthusiasm", etc., budget.)

MV analysis currently suffers under longstanding methodological issues that severely limit its usefulness in any context, financial or otherwise (). In a nutshell, noise in the data makes accurate estimation of returns and correlations difficult. This means that one is optimizing over a great deal of noise. In the present adaptation of MV analyis, I propose to define the returns vector as a linear combination of the retained correlation matrix eigenvectors. This, in turn, automatically purges the correlation matrix of noisy elements. The problem is then set up for optimization over signal, not noise.

This set-up also results in a structuring of the problem that allows for non-market valuation of each of the cross-cutting tendencies associated with each eigenvector---i.e. it endogenously determines the development agency's implicit willingness to pay for more of this or that cross-cutting tendency. This could be used to determine a given agency's investment preferences based on their observed spending. It could also become important later on in the formation of SDG markets (analogous to carbon markets) and/or initial coin offerings.

Many in the international development community may be unfamiliar with MV analysis. To build motivation and intuition for its application in the development context, I first walk through an example of its application in the financial context where it originated.

### Summary of results

In the SDG Tracker data, three signals are pulled from the noise. Loadings on the first eigenvector are evenly distributed. Loadings on the second eigenvector eigenvector captures agricultural and/or natural resource intensive development, associated with relatively higher emissions and low industrial development, trade, and overall GDP growth.
...

## Method

## Data

Yahoo data

WDI data . This is the data that the UN (SDG Tracker) uses to track progress towards SDGs.

## Modified MV analysis in the financial context

The data below are intended to be representative of what a broad-minded investor might have on their radar screen these days, covering a wide range of asset classes.


## Mod-MV analysis to determine optimal investments across strategic objectives in the development context

## Conclusion

$$R = \mathbf{w \cdot r}, \:\:\: C=\mathbf{w\cdot1}, \:\:\: V = \mathbf{w\cdot K \cdot w} \tag{1}$$


$$\max_{\mathbf{w}}{R} \:\:\:\:s.t. \:\:\: C=\overline{C} \:, \:\:\: V = \overline{V} \tag{2}$$

$$\mathcal{L} = R - \lambda_C(C - \overline{C}) - \lambda_{V}(V - \overline{V}) \tag{3}$$

$$\nabla \mathcal{L} = \mathbf{r} - \lambda_C \mathbf{1} - 2 \lambda_{V} K \cdot \mathbf{w} = \mathbf{0} \tag{4}$$

$$R^* = \lambda_C \overline{C} + 2 \lambda_V \overline{V} \tag{5}$$
Note this implies that the risk shadow price is proportional to the expected reward to risk ratio.

$$\lambda_V = \frac{1}{2} \frac{R^* - \lambda_C \overline{C}}{\overline{V}} \tag{6}$$


$$K^{-1} \cdot (\mathbf{r} - \lambda_C \mathbf{1}) = 2 \lambda_{V} \mathbf{w}^* \tag{5}$$

$$K^{-1} \cdot [\mathbf{r}, \: \mathbf{1}] \left[\begin{matrix} 1 \\ -\lambda_C \\ \end{matrix} \right] = 2 \lambda_{V} \mathbf{w}^* \tag{6}$$

$$ M\left[\begin{matrix}
1 \\
-\lambda_C \\
\end{matrix} \right] = 2 \lambda_{V} \left[\begin{matrix}
R \\
\bar{C} \\
\end{matrix} \right] \tag{7}$$

where 

$$M = [\mathbf{r}, \: \mathbf{1}]' \cdot K^{-1} \cdot [\mathbf{r}, \: \mathbf{1}] \tag{8}$$

$$\left[\begin{matrix}
1 \\
-\lambda_C \\
\end{matrix} \right] = 2 \lambda_{V} M^{-1} \left[\begin{matrix}
R \\
\bar{C} \\
\end{matrix} \right] \tag{9}$$

However, mean returns are notoriously difficult to measure.

$$\mathbf{r} = \tilde{P} \tilde{\Lambda} \cdot \mathbf{1}= \lambda_{1} \mathbf{p_1} + \lambda_{2} \mathbf{p_2} + \cdots +\lambda_{k} \mathbf{p_k} \tag{10}$$

$$K = P \Lambda P' \tag{11}$$


$$M = [\tilde{P}, \: \mathbf{1}]' \cdot K^{-1} \cdot [\tilde{P}, \: \mathbf{1}] \tag{12}$$


or

$$M = \left[\begin{matrix} 1/ \lambda_{1} & 0 & \cdots & 0 & 1/ \lambda_1 \mathbf{p_1} \cdot \mathbf{1} \\ 0 & 1/ \lambda_{2} & \cdots & 0 & 1/ \lambda_2 \mathbf{p_2} \cdot \mathbf{1} \\ \vdots & \vdots & \ddots & 0 & \vdots \\ 0 & 0 & 0 & 1/ \lambda_{k} & 1/ \lambda_k \mathbf{p_k} \cdot \mathbf{1}  \\ 1/ \lambda_1 \mathbf{1} \cdot \mathbf{p_1} & 1/ \lambda_2 \mathbf{1} \cdot \mathbf{p_2} & \cdots & 1/ \lambda_k \mathbf{1} \cdot \mathbf{p_k} & \mathbf{1} \cdot K \cdot \mathbf{1} \end{matrix} \right]$$

<!-- $$\left[\begin{matrix} \gamma_{1} \\ \gamma_{2} \\ \vdots \\ \gamma_{k} \\ -\gamma_C \\ \end{matrix} \right] = 2 \gamma_v \tilde{\Lambda} \left[\begin{matrix} r_1 \\ r_2 \\ \vdots \\ r_k \\ \bar{C} \\ \end{matrix} \right] - \gamma_c \left[ \begin{matrix} \mathbf{p}_1 \cdot \mathbf{1} \end{matrix} \right] \tag{13}$$ -->


$$\gamma_i = 2 \gamma_v \lambda_i r_i + \gamma_c \mathbf{p}_i \cdot \mathbf{1} \: ; \:\:\: i=1,2,\cdots,k \tag{}$$

$$\gamma_c =  \gamma_1 / \lambda_1 \mathbf{1} \cdot \mathbf{p_1} + \gamma_2 / \lambda_2 \mathbf{1} \cdot \mathbf{p_2} + \cdots + \gamma_k / \lambda_k \mathbf{1} \cdot \mathbf{p_k} + \gamma_c \mathbf{1} \cdot K \cdot \mathbf{1}$$

$$ -\frac{1}{2 \gamma_v}[\tilde{P}\tilde{\Lambda}^{-1}, \mathbf{1}] \left[\begin{matrix} \gamma_{1} \\ \gamma_{2} \\ \vdots \\ \gamma_{k} \\ -\gamma_c \\ \end{matrix} \right] = \mathbf{w}^* \tag{14}$$

$$-\frac{1}{2 \gamma_v}[\tilde{P}\tilde{\Lambda}^{-1}, \mathbf{1}] \cdot \mathbf{\gamma} =  \mathbf{w}^* \tag{5}$$




```{r, fig.width=10, fig.height=4, fig.align='center', echo = FALSE}
#setwd("D:/OneDrive - CGIAR/Documents")
#options(warn = -1); options(scipen = 999)
#-------------------------------------------------------------
library(plyr)
library(tidyverse)
library(ggplot2)
library(zoo)
library(FactoMineR)
library(factoextra)
library(Hmisc)
library(corrplot)
library(tidyquant)
#-------------------------------------------------------------

Signals_from_noise <- function(mat_in, varimax_rot = T,
                               list_tsTypes = NULL,
                               tsType_names = NULL,
                               pca_var_plot = F,
                               pca_ind_plot = F,
                               eigenvalue_density_plot = F,
                               sig_corr_plot = F,
                               yearly = F){
  col_order <- colnames(mat_in)
  date_vec <- row.names(mat_in)
  if(yearly){date_vec <- as.integer(date_vec)}
  n_ts <- ncol(mat_in)
  #----
  if(!is.null(list_tsTypes)){
    group_vec <- rep(NA, n_ts)
    for(i in 1:length(list_tsTypes)){
      this_tsType_vec <- list_tsTypes[[i]]
      this_tsType_name <- tsType_names[i]
      group_vec[which(col_order %in% this_tsType_vec)] <- this_tsType_name
      
    }
  }
  #----
  if(pca_ind_plot){
    res <- FactoMineR::PCA(t(mat_in), graph = F)
    gg <- factoextra::fviz_pca_ind(res, habillage = factor(group_vec), addEllipses = T)
    print(gg)
  }
  #----
  res <- FactoMineR::PCA(mat_in, ncp = ncol(mat_in), graph = F)
  #----
  if(pca_var_plot){
    gg <- factoextra::fviz_pca_var(res, habillage = factor(group_vec))
    print(gg)
  }
  # library(mclust)
  # mc <- Mclust(t(mat_in))
  # summary(mc)
  # View(mc$classification)
  # factoextra::fviz_cluster(mc, frame.type = "norm", geom = "text")
  #--Extraction of signals (main PCs)
  lam_cor <- as.data.frame(res$eig)$eigenvalue
  lamcor_max <- max(lam_cor)
  N_t <- nrow(mat_in)
  N_c <- ncol(mat_in)
  Q <- N_t / N_c
  s_sq <- 1 - lamcor_max / N_c
  #s_sq <- 1
  lamrand_max <- s_sq * (1 + 1 / Q + 2 / sqrt(Q))
  lamrand_min <- s_sq * (1 + 1 / Q - 2 / sqrt(Q))
  lam <- seq(lamrand_min, lamrand_max, 0.001)
  dens_rand <- Q / (2 * pi * s_sq) * sqrt((lamrand_max - lam) * (lam - lamrand_min)) / lam
  df_e <- data.frame(eigenvalues = lam_cor)
  #--Eigenvalue density vs. random matrix eigenvalue density
  if(eigenvalue_density_plot){
    gg <- ggplot()
    gg <- gg + geom_density(data = df_e, aes(x = eigenvalues, color = "Correlation Matrix"), lwd = 1.1)
    gg <- gg + geom_line(data = data.frame(x = lam, y = dens_rand), aes(x = x, y = y, color = "Random matrix"), lwd = 1.1)
    gg <- gg + scale_colour_manual(name = "Eigenvalue density", 
                                   values = c(`Correlation Matrix` = "blue", `Random matrix` = "orange"))
    print(gg)
  }
  #-----------------------------------------
  ind_deviating_from_noise <- which(lam_cor > lamrand_max)# (lamrand_max + 5 * 10^-1))
  mat_Loads <- res$var$coord
  mat_signal_Loads <- mat_Loads[, ind_deviating_from_noise]
  mat_Loads_rot <- varimax(mat_Loads)[[1]]
  mat_signal_Loads_rot <- mat_Loads_rot[, ind_deviating_from_noise]
  mat_eigvecs <-  mat_Loads %*% diag(1 / sqrt(lam_cor))
  lam_signals <- lam_cor[ind_deviating_from_noise]
  n_signals <- length(lam_signals)
  print(paste("Number of signals: ", n_signals))
  mat_signal_eigvecs <- mat_eigvecs[, ind_deviating_from_noise]
  mat_signal_ts <- mat_in %*% mat_signal_eigvecs
  if(n_signals == 1){
    mat_signal_ts <- mat_signal_ts / lam_signals
  }else{
    mat_signal_ts <- mat_signal_ts %*% diag(1 / lam_signals)
  }
  # Set sign of eigenvectors such that they
  # best conform to the input time series
  ts_avg <- mat_in %*% rep(1, n_ts) * 1 / n_ts
  # if(n_signals == 1){
  #   sse <- sum((mat_signal_ts - ts_avg)^2)
  #   sse_neg <- sum((-mat_signal_ts - ts_avg)^2)
  #   if(sse_neg < sse){
  #     mat_signal_eigvecs <- -mat_signal_eigvecs
  #     mat_signal_ts <- -mat_signal_ts
  #   }
  # }else{
  #   for(i in 1:n_signals){
  #     sse <- sum((mat_signal_ts[, i] - ts_avg)^2)
  #     sse_neg <- sum((-mat_signal_ts[, i] - ts_avg)^2)
  #     sse_vec <- c(sse, sse_neg)
  #     if(sse_neg < sse){
  #       mat_signal_eigvecs[, i] <- -mat_signal_eigvecs[, i]
  #       mat_signal_ts[, i] <- -mat_signal_ts[, i]
  #     }
  #   }
  #   
  # }
  #------------------------------------------------------------
  # Plot loadings barcharts
  if(varimax_rot){
      df_plot <- data.frame(ts_id = col_order, mat_signal_Loads_rot)
  }else{
      df_plot <- data.frame(ts_id = col_order, mat_signal_Loads)
  }
  signal_id <- paste("Signal", c(1:n_signals))
  colnames(df_plot)[2:(n_signals + 1)] <- signal_id
  gathercols <- as.character(signal_id)
  df_plot <- gather_(df_plot, "Signal", "Loading", gathercols)
  #--
  if(!is.null(list_tsTypes)){
    # df_plot$Type <- NA
    # u <- as.character(df_plot$ts)
    # for(i in 1:length(list_tsTypes)){
    #   ind <- which(u %in% list_tsTypes[[i]])
    #   df_plot$Type[ind] <- tsType_names[i]
    # }
    # df_plot$Type <- as.factor(df_plot$Type)
    df_plot$Type <- factor(group_vec)
    xx <- df_plot$Type
    df_plot$ts_id <- factor(df_plot$ts_id, levels = unique(df_plot$ts_id[order(xx)]))
    gg <- ggplot(df_plot, aes(x = ts_id, y = Loading, fill = Type))
  }else{
    gg <- ggplot(df_plot, aes(x = ts_id, y = Loading))
  }
  #--
  gg <- gg + geom_bar(stat = "identity", position = "dodge")
  gg <- gg + facet_wrap(~ Signal, nrow = 1)
  #gg <- gg + labs(title = )
  gg <- gg + theme(axis.text.y = element_text(face = "bold", size = 10),
                   axis.text.x = element_text(face = "bold", size = 10),
                   axis.title.y = element_text(face = "bold", size = 10),
                   axis.title.x = element_text(face = "bold", size = 10))
  gg <- gg + coord_equal()
  # if(N_c <= 50){
  #   gg <- gg + theme(axis.text.x = element_text(angle = 60, hjust = 1),
  #                    axis.title.y = element_blank())
  # }else{
  #   gg <- gg + theme(axis.text.x = element_blank(),
  #                    axis.title.y = element_blank())
  # }
  gg <- gg + coord_flip()
  print(gg)
  #---------------------------------
  # Plot signal ts against average
  df_plot1 <- data.frame(Date = date_vec, ts_avg)
  df_plot2 <- data.frame(Date = date_vec, mat_signal_ts)
  df_plot1$Date <- factor(format(df_plot1$Date, format = "%y-%m-%d%"), ordered = T)
  df_plot2$Date <- factor(format(df_plot2$Date, format = "%y-%m-%d%"), ordered = T)
  xAxis_labels <- df_plot1$Date[seq(1, nrow(df_plot1), length.out = 10)]
  signal_id <- paste("Signal", c(1:n_signals))
  colnames(df_plot2)[2:(n_signals + 1)] <- signal_id
  gathercols <- signal_id
  df_plot2 <- df_plot2 %>% gather_("Signal", "Value", gathercols)
  gg <- ggplot()
  gg <- gg + geom_line(data = df_plot1, aes(x = Date, y = ts_avg, group = 1), color = "orange", lwd = 2)
  gg <- gg + geom_line(data = df_plot2, aes(x = Date, y = Value, group = 1))
  gg <- gg + scale_x_discrete(breaks = xAxis_labels)
  gg <- gg + facet_wrap(~ Signal, ncol = 1)
  gg <- gg + theme(axis.title.y = element_blank())
  gg
  print(gg)
  #--Correlation matrix
  if(sig_corr_plot){
    # t(mat_signal_ts) %*% mat_signal_ts
    # t(mat_signal_eigvecs) %*% mat_signal_eigvecs
    rcorr_out <- rcorr(mat_signal_ts)
    cormat <- rcorr_out$r
    print(cormat)
    pmat <- rcorr_out$P
    corrplot(cormat, type="upper", order="hclust", p.mat = pmat, sig.level = 0.01, insig = "blank", tl.col = "black", tl.srt = 45)
    
  }
  #---------------------------------
  df_sig_ts <- data.frame(date = date_vec, ts_sigs = mat_signal_ts)
  #df_sig_eigvecs <- data.frame(Loadings_sigs_rot = mat_signal_Loads_rot)
  list_out <- list(df_sig_ts, mat_signal_eigvecs, mat_eigvecs, mat_signal_Loads, mat_signal_Loads_rot, lam_signals, lam_cor)
  return(list_out)
}



spy_sector_symbs <- c("XLF", "XLC", "XLY", "XLP", "XLV", "XLK", "RWR",
                      "XLU", "XLI", "XBI", "IYT") #"TTEK"
spy_sector_detail <- c("Financials", "Communications", "Luxury goods", "Staple goods",
                       "Healthcare", "Technology", "Real estate", "Utilities", "Industrial",
                       "Biotechnology", "Transportation") #"Gov. foreign aid"
minerals_symbs <- c("GLD", "SLV", "PPLT", "JJC", "JJM") #"XME"
minerals_detail <- c("Gold", "Silver", "Platinum", "Copper", "Industrial metals") #"US metals and mining"
agriculture_symbs <- c("JJG", "BAL", "SOYB", "SGG", "JO", "NIB", "DBA")
agriculture_detail <- c("Grains", "Cotton", "Soybean", "Sugar", "Coffee", "Cacao", "General agriculture")
energy_symbs <- c("WTI", "FUE", "WOOD", "ICLN", "KOL", "UNG")
energy_detail <- c("Oil (W&T Offshore Inc.)", "Biofuels", "Timber", "Clean energy", "Coal", "US natural gas")
#currency_symbs <- c("EMLC", "UUP", "FXE", "FXY", "FXF", "FXC", "FXB", "FXA")
#currency_detail <- c("Emerging mkt currencies", "USD", "EUR", "JPY", "CHF", "CND", "GBP", "AUD")
currency_symbs <- c("EURUSD=X", "JPY=X", "CHF=X", "CAD=X",
                    "GBPUSD=X", "AUDUSD=X", "INR=X")
currency_detail <- c("EUR/USD", "USD/JPY",
                     "USD/CHF", "USD/CAD", "GBP/USD", "AUD/USD", "USD/INR")
emerg_mkt_symbs <- c("EMLC", "ELD", "BKF", "VWOB")
emerg_mkt_detail <- c("Emerg mkts debt", "Emerg mkts gov. bonds", "BRIC countries", "Emerging mkt currencies")
crypto_symbs <- c("BLOK", "LEGR", "BCNA")
crypto_detail <- c("Blockchain tech.", "Blockchain companies", "Blockchain in China")
Tbond_symbs <- c("IEI", "IEF", "TLT")#, "BIL"
Tbond_detail <- c("T-bond 3-7 yrs", "T-bond 7-10 yrs", "T-bond 20+ yrs") #"T-bond 1-3 months"

ts_symb_vec <- c(spy_sector_symbs, minerals_symbs, agriculture_symbs, energy_symbs,
                 currency_symbs, emerg_mkt_symbs, crypto_symbs, Tbond_symbs)
ts_detail_vec <- c(spy_sector_detail, minerals_detail, agriculture_detail, energy_detail,
                   currency_detail, emerg_mkt_detail, crypto_detail, Tbond_detail)
df_symb_detail <- data.frame(symbol = ts_symb_vec, detail = ts_detail_vec)
#--
length(ts_symb_vec)
#--
# list_tsTypes <- list(spy_sector_symbs, minerals_symbs, agriculture_symbs, energy_symbs,
#                      currency_symbs, emerg_mkt_symbs, crypto_symbs, Tbond_symbs)
list_tsTypes <- list(spy_sector_detail, minerals_detail, agriculture_detail, energy_detail,
                     currency_detail, emerg_mkt_detail, crypto_detail, Tbond_detail)
tsType_names <- c("US Sectors", "Minerals", "Agriculture", "Energy", "Major Currency Pairs",
                  "Emerging Markets", "Cryptocurrencies/Blockchain", "T-Bonds")
#--
#per_ema <- 13
#fromdate = Sys.Date() - 360
fromdate = "2018-06-20"
tbl_ohlcv <- tq_get(ts_symb_vec, get = "stock.prices", from = fromdate)
df_ohlcv <- as.data.frame(tbl_ohlcv)
#--
# Crypto ts can have duplicate date entries sometimes (BTC-USD)
# Get rid of these duplicates, if any
df_ohlcv <- as.data.frame(df_ohlcv %>% group_by(symbol) %>% mutate(dup = duplicated(date)))
df_ohlcv <- subset(df_ohlcv, dup == F)
df_ohlcv$dup <- NULL
#--

#df_ohlcv$p <- rowSums(df_ohlcv[, c(4:6)]) / 3
#--
#df <- df_ohlcv[, c("date", "symbol", "p")]
# df <- df_ohlcv %>% group_by(symbol) %>% tq_transmute(select = adjusted, 
#                      mutate_fun = periodReturn, 
#                      period     = "monthly")
#--
df <- df_ohlcv[, c("date", "symbol", "adjusted")]
df <- df %>% spread(symbol, adjusted)
ind_shift <- which(colnames(df) %in% currency_symbs)
df[, ind_shift] <- rbind(rep(NA, length(ind_shift)), df[-nrow(df), ind_shift])
df <- df[-c(1, nrow(df)), ]
date_vec <- df$date
mat_ts <- na.approx(df[, -1])

o <- apply(mat_ts, 2, function(x) length(which(is.na(x))))
#table(o)
#which(o==1)
xts_ts <- xts(mat_ts, date_vec)
# mat_ts_mo <- as.matrix(to.monthly(xts_ts, OHLC = F))
# mat_ts_wk <- as.matrix(to.weekly(xts_ts, OHLC = F))
date_vec <- index(xts_ts)
mat_ts <- mat_ts
#ind_rm_ema <- 1:(per_ema - 1)
# mat_in <- apply(mat_in, 2, function(x) x - EMA(x, per_ema))
# mat_in <- mat_in[-ind_rm_ema, ]
# date_vec <- df$date[-c(ind_rm_ema, ind_rm_na)]
mat_diff_mo <- diff(mat_ts_mo) / mat_ts_mo[-nrow(mat_ts_mo), ] * 100
mat_in <- diff(mat_ts) / mat_ts[-nrow(mat_ts), ] * 100
date_vec <- date_vec[-1]
#length(date_vec)
row.names(mat_in) <- as.character(date_vec)
colnames(mat_in) <- as.character(df_symb_detail$detail[order(df_symb_detail$symbol)])

df_plot <- as.data.frame(mat_in)
gathercols <- colnames(df_plot)
df_plot$Date <- date_vec
df_plot <- df_plot %>% gather_("Security", "Weekly change (%)", gathercols)
df_plot$Type <- NA
df_plot$Type[which(df_plot$Security %in% spy_sector_detail)] <- "US Sectors"
df_plot$Type[which(df_plot$Security %in% minerals_detail)] <- "Minerals"
df_plot$Type[which(df_plot$Security %in% agriculture_detail)] <- "Agriculture"
df_plot$Type[which(df_plot$Security %in% energy_detail)] <- "Energy"
df_plot$Type[which(df_plot$Security %in% currency_detail)] <- "Major Currency Pairs"
df_plot$Type[which(df_plot$Security %in% emerg_mkt_detail)] <- "Emerging Markets"
df_plot$Type[which(df_plot$Security %in% crypto_detail)] <- "Cryptocurrencies/Blockchain"
df_plot$Type[which(df_plot$Security %in% Tbond_detail)] <- "T-bonds"
#------------------------------------------------------------
# gg <- ggplot(df_plot, aes(x = Year, y = Value, group = Security, color = Security))
# gg <- gg + geom_line()
# gg <- gg + facet_wrap(~ Type, nrow = 3, scales = "free")
# gg <- gg + theme(legend.position = "none")
# gg
#------------------------------------------------------------
this_type <- "US Sectors"
df_plot2 <- subset(df_plot, Type == this_type)
gg <- ggplot(df_plot2, aes(x = Date, y = `Weekly change (%)`, group = Security, color = Security))
gg <- gg + geom_line(lwd = 1.1)
gg <- gg + geom_point(size = 2)
gg <- gg + labs(title = this_type)
gg
this_type <- "Minerals"
df_plot2 <- subset(df_plot, Type == this_type)
gg <- ggplot(df_plot2, aes(x = Date, y = `Weekly change (%)`, group = Security, color = Security))
gg <- gg + geom_line(lwd = 1.1)
gg <- gg + geom_point(size = 2)
gg <- gg + labs(title = this_type)
gg
this_type <- "Agriculture"
df_plot2 <- subset(df_plot, Type == this_type)
gg <- ggplot(df_plot2, aes(x = Date, y = `Weekly change (%)`, group = Security, color = Security))
gg <- gg + geom_line(lwd = 1.1)
gg <- gg + geom_point(size = 2)
gg <- gg + labs(title = this_type)
gg
this_type <- "Energy"
df_plot2 <- subset(df_plot, Type == this_type)
gg <- ggplot(df_plot2, aes(x = Date, y = `Weekly change (%)`, group = Security, color = Security))
gg <- gg + geom_line(lwd = 1.1)
gg <- gg + geom_point(size = 2)
gg <- gg + labs(title = this_type)
gg
this_type <- "Major Currency Pairs"
df_plot2 <- subset(df_plot, Type == this_type)
gg <- ggplot(df_plot2, aes(x = Date, y = `Weekly change (%)`, group = Security, color = Security))
gg <- gg + geom_line(lwd = 1.1)
gg <- gg + geom_point(size = 2)
gg <- gg + labs(title = this_type)
gg
this_type <- "Emerging Markets"
df_plot2 <- subset(df_plot, Type == this_type)
gg <- ggplot(df_plot2, aes(x = Date, y = `Weekly change (%)`, group = Security, color = Security))
gg <- gg + geom_line(lwd = 1.1)
gg <- gg + geom_point(size = 2)
gg <- gg + labs(title = this_type)
gg
this_type <- "Cryptocurrencies/Blockchain"
df_plot2 <- subset(df_plot, Type == this_type)
gg <- ggplot(df_plot2, aes(x = Date, y = `Weekly change (%)`, group = Security, color = Security))
gg <- gg + geom_line(lwd = 1.1)
gg <- gg + geom_point(size = 2)
gg <- gg + labs(title = this_type)
gg
this_type <- "T-bonds"
df_plot2 <- subset(df_plot, Type == this_type)
gg <- ggplot(df_plot2, aes(x = Date, y = `Weekly change (%)`, group = Security, color = Security))
gg <- gg + geom_line(lwd = 1.1)
gg <- gg + geom_point(size = 2)
gg <- gg + labs(title = this_type)
gg


```



```{r, fig.width=15, fig.height=12, fig.align='center', echo=FALSE}
list_sigs <- Signals_from_noise(mat_in, varimax_rot = T,
                                list_tsTypes = list_tsTypes,
                                tsType_names = tsType_names,
                                pca_var_plot = T,
                                pca_ind_plot = T,
                                eigenvalue_density_plot = T,
                                sig_corr_plot = F,
                                yearly = F)


```


```{r, fig.width=13, fig.height=11, fig.align='center', echo=FALSE}

# list(df_sig_ts, mat_sig_eigvecs, mat_eigvecs, mat_signal_Loads, mat_signal_Loads_rot, lam_signals, lam_cor, mat_eigvecs)

L <- list_sigs[[4]]
#t(L) %*% L
mse <- mean((cor(mat_in) - L %*% t(L))^2)
sse <- sum((cor(mat_in) - L %*% t(L))^2)
mse
sse
#((cor(mat_in)) / (L %*% t(L)))[1:4, 1:4]

# out <- varimax(L)
# L_rot <- out[[1]]
# rotmat <- out[[2]]
# L %*% rotmat - L_rot
# round(L %*% rotmat, 2)
# L_rot <- L %*% rotmat
# round(L %*% t(L) - L_rot %*% t(L_rot), 2)


# colSums(mat_Loads[,1:n_sigs])
# colSums(mat_Loads_rot[,1:n_sigs])
mat_sig_eigvecs <- list_sigs[[2]]
n_sigs <- ncol(mat_sig_eigvecs)
mat_eigvecs <- as.matrix(list_sigs[[3]])
eigvals_sig <- eigvals <- list_sigs[[6]]
eigvals <- list_sigs[[7]]
ones_vec <- rep(1, nrow(mat_eigvecs))
mat_sig_eigvecs_aug <- cbind(mat_sig_eigvecs, ones_vec)

# t(mat_sig_eigvecs) %*% mat_eigvecs %*% diag(1 / eigvals) %*% t(mat_eigvecs) %*% ones_vec

# mat_sig_ts <- mat_ts %*% mat_sig_eigvecs
# mat_sig_ts <- scale(mat_sig_ts)
# ts_avg <- rowMeans(mat_ts)
# ts_avg <- scale(ts_avg)
# n_sigs <- ncol(mat_sig_eigvecs)
# df_plot1 <- data.frame(Date = row.names(mat_sig_ts), ts_avg)
# colnames(df_plot1)[2] <- "Average"
# df_plot2 <- data.frame(Date = row.names(mat_sig_ts), mat_sig_ts)
# df_plot1$Date <- factor(format(df_plot1$Date, format = "%y-%m-%d%"), ordered = T)
# df_plot2$Date <- factor(format(df_plot2$Date, format = "%y-%m-%d%"), ordered = T)
# #df_plot2$PC_sigs.2 <- -df_plot2$PC_sigs.2
# xAxis_labels <- df_plot1$Date[seq(1, nrow(df_plot1), length.out = 10)]
# colnames(df_plot2)[2:ncol(df_plot2)] <- paste("Signal", c(1:n_sigs))
# gathercols <- colnames(df_plot2)[2:ncol(df_plot2)]
# df_plot2 <- df_plot2 %>% gather_("Signal", "Value", gathercols)
# gg <- ggplot()
# gg <- gg + geom_line(data = df_plot1, aes(x = Date, y = Average, group = 1), color = "orange", lwd = 2)
# gg <- gg + geom_line(data = df_plot2, aes(x = Date, y = Value, group = 1))
# gg <- gg + scale_x_discrete(breaks = xAxis_labels)
# gg <- gg + facet_wrap(~Signal, ncol = 1)
# gg




# r_trad <- xts
# M_trad <- 



Q <- t(mat_sig_eigvecs_aug) %*% mat_eigvecs
# M <- round(Q %*% diag(1 / eigvals) %*% t(mat_eigvecs) %*% mat_sig_eigvecs_aug, 6)
M <- round(Q %*% diag(1 / eigvals) %*% t(Q), 7)
M
M_inv <- round(solve(M), 5)
M_inv

# round(t(mat_sig_eigvecs) %*% mat_eigvecs %*% diag(1 / eigvals) %*% t(mat_eigvecs) %*% mat_sig_eigvecs, 3)
# round(t(mat_sig_eigvecs) %*% mat_eigvecs %*% diag(1 / eigvals) %*% t(mat_eigvecs) %*% ones_vec, 3)
# round(t(ones_vec) %*% mat_eigvecs %*% diag(1 / eigvals) %*% t(mat_eigvecs) %*% mat_sig_eigvecs, 3)
# round(t(ones_vec) %*% mat_eigvecs %*% diag(1 / eigvals) %*% t(mat_eigvecs) %*% ones_vec, 3)
# 
# round(t(mat_sig_eigvecs) %*% mat_eigvecs %*% diag(1 / eigvals) %*% t(mat_eigvecs) %*% mat_sig_eigvecs, 3)



#eigvals_sig / diag(M_inv)
# t(mat_eigvecs[, 1]) %*% mat_eigvecs %*% diag(1 / eigvals) %*% t(mat_eigvecs)
# 1 / eigvals[1] * t(mat_eigvecs[, 1]) %*% ones_vec
#-----------------------------------------------
#-----------------------------------------------
budget <- 10^5
l_C <- -1 / budget * 10^1
targ_vec <-  c(0.15 * rep(1, n_sigs), 1)
#targ_vec <- c(0.06, 0.06, 0.02, 0.02, 1)
x <- -2 * M_inv %*% targ_vec
l_V <- l_C / x[length(x)]
l_V
lambdas <- l_V * x
lambdas
lambdas * budget
l_V * budget
# cormat <- cor(mat_in)
# cormat_inv <- solve(cormat)
# w_star <- -1 / (2 * l_V) * cormat_inv %*% mat_sig_eigvecs_aug %*% lambdas
# sum(w_star)

# l_R <- 1
# targ_vec <-  c(0.15 * rep(1, n_sigs), 1)
# #targ_vec <- c(0.06, 0.06, 0.02, 0.02, 1)
# x <- -2 * M_inv %*% targ_vec
# x
# l_V <- l_R / x[1]
# l_V <- l_V * (-sign(l_V))
# l_V
# lambdas <- l_V * x
# lambdas

w_star <- -1 / (2 * l_V) * mat_eigvecs %*% diag(1 / eigvals) %*% t(mat_eigvecs) %*% mat_sig_eigvecs_aug %*% lambdas

w_star_check <- -1 / (2 * l_V) * (mat_eigvecs %*% diag(1 / eigvals) %*% t(mat_eigvecs) %*% mat_sig_eigvecs %*% lambdas[1:n_sigs] + l_C * mat_eigvecs %*% diag(1 / eigvals) %*% t(mat_eigvecs) %*% ones_vec)
w_star - w_star_check
sum(w_star)
sum(w_star_check)
# w_star <- -w_star
# sum(w_star)
# cormat <- cor(mat_in)
# cormat_inv <- solve(cormat)
# w_star <- -1 / (2 * l_V) * cormat_inv %*% mat_sig_eigvecs_aug %*% lambdas
# sum(w_star)
#-----------------------------------------------
#-----------------------------------------------
# mat_Loads <- list_sigs[[4]]
# colMeans(mat_in)
# mat_sig_eigvecs %*% eigvals_sig / colMeans(mat_in)




mat_Loads_rot <- list_sigs[[5]]
w_star_normd <- w_star / max(abs(w_star))
col_order <- colnames(mat_in)
df_plot <- data.frame(ts_id = col_order, mat_Loads_rot, w_star_normd)
signal_id <- paste("Signal", c(1:n_sigs))
colnames(df_plot)[2:(n_sigs + 1)] <- signal_id
colnames(df_plot)[ncol(df_plot)] <- "Portfolio weights"
gathercols <- colnames(df_plot)[-1]
df_plot <- gather_(df_plot, "Signal", "Loading", gathercols)
#--
n_ts <- ncol(mat_in)
group_vec <- rep(NA, n_ts)
for(i in 1:length(list_tsTypes)){
  this_tsType_vec <- list_tsTypes[[i]]
  this_tsType_name <- tsType_names[i]
  group_vec[which(col_order %in% this_tsType_vec)] <- this_tsType_name

}

df_plot$Type <- factor(group_vec)
xx <- df_plot$Type
df_plot$ts_id <- factor(df_plot$ts_id, levels = unique(df_plot$ts_id[order(xx)]))
gg <- ggplot(df_plot, aes(x = ts_id, y = Loading, fill = Type))
#--
gg <- gg + geom_bar(stat = "identity", position = "dodge")
gg <- gg + facet_wrap(~ Signal, nrow = 1)
#gg <- gg + labs(title = )
gg <- gg + theme(axis.text.y = element_text(face = "bold", size = 10),
                 axis.text.x = element_text(face = "bold", size = 10),
                 axis.title.y = element_text(face = "bold", size = 10),
                 axis.title.x = element_text(face = "bold", size = 10))
#gg <- gg + coord_equal()
# if(N_c <= 50){
#   gg <- gg + theme(axis.text.x = element_text(angle = 60, hjust = 1),
#                    axis.title.y = element_blank())
# }else{
#   gg <- gg + theme(axis.text.x = element_blank(),
#                    axis.title.y = element_blank())
# }
gg <- gg + coord_flip()
gg


# Backtesting
mat_Loads_rot_normd <- apply(mat_Loads_rot, 2, function(x) x / sum(x))
#-------------------------------------
# Monthly
mat_diff_mo <- diff(mat_ts) / mat_ts[-nrow(mat_ts), ] * 100
mat_sig_ts_mo <- mat_diff_mo %*% mat_Loads_rot_normd
ts_avg <- rowMeans(mat_diff_mo)
ts_wstar <- mat_diff_mo %*% w_star
mat_comp_ts <- cbind(ts_avg, ts_wstar, mat_sig_ts)
xts_comp_ts <- xts(mat_comp_ts, date_vec)
mat_comp_ts_mo <- as.matrix(to.monthly(xts_comp_ts, OHLC = F))
mat_comp_ts_mo_perform <- apply(mat_comp_ts_mo, 2, function(x) x - mat_comp_ts_mo[, 1])
df_plot <- data.frame(Date = row.names(mat_comp_ts_mo_perform), mat_comp_ts_mo_perform)
#df_plot <- data.frame(Date = row.names(mat_comp_ts_mo), mat_comp_ts_mo)
colnames(df_plot)[-1] <- c("Average", "Optimal Portfolio", paste("Eigenportfolio", 1:n_sigs))
df_plot_base <- df_plot[, c("Date", "Average")]
df_plot$Average <- NULL
gathercols <- colnames(df_plot)[-1]
#df_plot <- df_plot %>% gather_("Type", "Monthly Return (%)", gathercols)
df_plot <- df_plot %>% gather_("Type", "Performance (Pct. point diff. from average)", gathercols)
gg <- ggplot()
gg <- gg + geom_line(data = df_plot_base, aes(x = Date, y = Average, group = 1), color = "orange", lwd = 2)
gg <- gg + geom_line(data = df_plot, aes(x = Date, y = `Performance (Pct. point diff. from average)`, group = 1))
gg <- gg + facet_wrap(~Type, ncol = 1, scales = "free")
gg <- gg + labs(y = "Performance (Pct. point diff. from average)")
gg

n_positive_mos <- apply(mat_comp_ts_mo_perform, 2, function(x) length(which(x > 0)))
sd_perform <- apply(mat_comp_ts_mo_perform, 2, function(x) sd(x[which(x > 0)]))
mu_perform <- apply(mat_comp_ts_mo_perform, 2, function(x) mean(x[which(x > 0)]))
sd_perform <- apply(mat_comp_ts_mo_perform, 2, sd)
mu_perform <- colMeans(mat_comp_ts_mo_perform)
cv_perform <- sd_perform / mu_perform
knitr::kable(data.frame(n_positive_mos, mu_perform, cv_perform, sd_perform))
mu_ret <- colMeans(mat_comp_ts_mo)
sd_ret <- apply(mat_comp_ts_mo, 2, sd)
cv_ret <- sd_ret / mu_ret
knitr::kable(data.frame(n_positive_mos, mu_ret, cv_ret, sd_ret))
#-------------------------------------
# Weekly
mat_comp_ts_wk <- as.matrix(to.weekly(xts_comp_ts, OHLC = F))
mat_comp_ts_wk_perform <- apply(mat_comp_ts_wk, 2, function(x) x - mat_comp_ts_wk[, 1])
df_plot <- data.frame(Date = row.names(mat_comp_ts_wk_perform), mat_comp_ts_wk_perform)
#df_plot <- data.frame(Date = row.names(mat_comp_ts_wk), mat_comp_ts_wk)
colnames(df_plot)[-1] <- c("Average", "Optimal Portfolio", paste("Eigenportfolio", 1:n_sigs))
df_plot_base <- df_plot[, c("Date", "Average")]
df_plot$Average <- NULL
gathercols <- colnames(df_plot)[-1]
#df_plot <- df_plot %>% gather_("Type", "Monthly Return (%)", gathercols)
df_plot <- df_plot %>% gather_("Type", "Performance (Pct. point diff. from average)", gathercols)
gg <- ggplot()
gg <- gg + geom_line(data = df_plot_base, aes(x = Date, y = Average, group = 1), color = "orange", lwd = 2)
gg <- gg + geom_line(data = df_plot, aes(x = Date, y = `Performance (Pct. point diff. from average)`, group = 1))
gg <- gg + facet_wrap(~Type, ncol = 1, scales = "free")
gg <- gg + labs(y = "Performance (Pct. point diff. from average)")
gg

n_positive_wks <- apply(mat_comp_ts_wk_perform, 2, function(x) length(which(x > 0)))
sd_perform <- apply(mat_comp_ts_wk_perform, 2, function(x) sd(x[which(x > 0)]))
mu_perform <- apply(mat_comp_ts_wk_perform, 2, function(x) mean(x[which(x > 0)]))
sd_perform <- apply(mat_comp_ts_wk_perform, 2, sd)
mu_perform <- colMeans(mat_comp_ts_wk_perform)
cv_perform <- sd_perform / mu_perform
knitr::kable(data.frame(n_positive_wks, mu_perform, cv_perform, sd_perform))
mu_ret <- colMeans(mat_comp_ts_wk)
sd_ret <- apply(mat_comp_ts_wk, 2, sd)
cv_ret <- sd_ret / mu_ret
knitr::kable(data.frame(n_positive_wks, mu_ret, cv_ret, sd_ret))
#-------------------------------------
# Daily
mat_comp_ts_perform <- apply(mat_comp_ts, 2, function(x) x - mat_comp_ts[, 1])
df_plot <- data.frame(Date = row.names(mat_comp_ts_perform), mat_comp_ts_perform)
#df_plot <- data.frame(Date = row.names(mat_comp_ts), mat_comp_ts)
colnames(df_plot)[-1] <- c("Average", "Optimal Portfolio", paste("Eigenportfolio", 1:n_sigs))
df_plot_base <- df_plot[, c("Date", "Average")]
df_plot$Average <- NULL
gathercols <- colnames(df_plot)[-1]
#df_plot <- df_plot %>% gather_("Type", "Monthly Return (%)", gathercols)
df_plot <- df_plot %>% gather_("Type", "Performance (Pct. point diff. from average)", gathercols)
gg <- ggplot()
gg <- gg + geom_line(data = df_plot_base, aes(x = Date, y = Average, group = 1), color = "orange", lwd = 2)
gg <- gg + geom_line(data = df_plot, aes(x = Date, y = `Performance (Pct. point diff. from average)`, group = 1))
gg <- gg + facet_wrap(~Type, ncol = 1, scales = "free")
gg <- gg + labs(y = "Performance (Pct. point diff. from average)")
gg

n_positive <- apply(mat_comp_ts_perform, 2, function(x) length(which(x > 0)))
sd_perform <- apply(mat_comp_ts_perform, 2, function(x) sd(x[which(x > 0)]))
mu_perform <- apply(mat_comp_ts_perform, 2, function(x) mean(x[which(x > 0)]))
sd_perform <- apply(mat_comp_ts_perform, 2, sd)
mu_perform <- colMeans(mat_comp_ts_perform)
cv_perform <- sd_perform / mu_perform
knitr::kable(data.frame(n_positive, mu_perform, cv_perform, sd_perform))
mu_ret <- colMeans(mat_comp_ts)
sd_ret <- apply(mat_comp_ts, 2, sd)
cv_ret <- sd_ret / mu_ret
knitr::kable(data.frame(n_positive, mu_ret, cv_ret, sd_ret))










# mat_plot <- apply(cbind(ts_wstar, mat_sig_ts), 2, function(x) x - ts_avg)
# colMeans(mat_plot)
# colSums(mat_plot)
# df_plot <- data.frame(Date = row.names(mat_sig_ts), mat_plot)
# colnames(df_plot)[2] <- "Portfolio weights"
# df_plot$Date <- factor(format(df_plot$Date, format = "%y-%m-%d%"), ordered = T)
# xAxis_labels <- df_plot$Date[seq(1, nrow(df_plot), length.out = 10)]
# signal_id <- paste("Signal", c(1:n_sigs))
# colnames(df_plot)[3:ncol(df_plot)] <- signal_id
# gathercols <- colnames(df_plot)[2:ncol(df_plot)]
# df_plot <- df_plot %>% gather_("Signal", "Value", gathercols)
# gg <- ggplot(df_plot, aes(x = Date, y = Value, group = 1))
# gg <- gg + geom_line()
# gg <- gg <- gg + scale_x_discrete(breaks = xAxis_labels)
# gg <- gg + facet_wrap(~ Signal, ncol = 1)
# gg <- gg + theme(axis.title.y = element_blank())
# gg
# 
# 
# 
# 
# # Plot signal ts against average
# df_plot1 <- data.frame(Date = row.names(mat_sig_ts), ts_avg)
# df_plot2 <- data.frame(Date = row.names(mat_sig_ts), cbind(mat_sig_ts, ts_wstar))
# colnames(df_plot2)[ncol(df_plot2)] <- "Portfolio weights"
# df_plot1$Date <- factor(format(df_plot1$Date, format = "%y-%m-%d%"), ordered = T)
# df_plot2$Date <- factor(format(df_plot2$Date, format = "%y-%m-%d%"), ordered = T)
# xAxis_labels <- df_plot1$Date[seq(1, nrow(df_plot1), length.out = 10)]
# signal_id <- paste("Signal", c(1:n_sigs))
# colnames(df_plot2)[2:(n_sigs + 1)] <- signal_id
# gathercols <- colnames(df_plot2)[2:(n_sigs + 2)]
# df_plot2 <- df_plot2 %>% gather_("Signal", "Value", gathercols)
# gg <- ggplot()
# gg <- gg + geom_line(data = df_plot1, aes(x = Date, y = ts_avg, group = 1), color = "orange", lwd = 2)
# gg <- gg + geom_line(data = df_plot2, aes(x = Date, y = Value, group = 1))
# gg <- gg + scale_x_discrete(breaks = xAxis_labels)
# gg <- gg + facet_wrap(~ Signal, ncol = 1)
# gg <- gg + theme(axis.title.y = element_blank())
# gg


```




```{r, fig.width=10, fig.height=4, fig.align='center', echo = FALSE }


budget <- 10^5
l_C <- -1 / budget * 10^2
#l_R <- 1
#l_V <- -1.1
r_lev <- seq(0.11, 1.2, length.out = 100)
NR_vec <- c()
V_vec <- c()
lC_vec <- c()
lV_vec <- c()
list_wStar <- list()
list_wStar_eNormd <- list()
list_lambdas <- list()
last_ewStarNmd <- 0
for(i in 1:length(r_lev)){
  targ_vec <- c(r_lev[i] * rep(1, n_sigs), 1)
  x <- -2 * M_inv %*% targ_vec
  l_V <- l_C / x[length(x)]
  #l_V <- l_R / x[1]
  l_V <- l_V * (-sign(l_V))
  #l_C <- l_V * x[length(x)]
  lambdas <- l_V * x
  #l_C <- lambdas[length(lambdas)]
  #l_C <- l_C * (-sign(l_V))
  NR_star <- targ_vec %*% lambdas
  V_tol_implicit <- -1 / 2 *  NR_star / l_V
  #w_star <- -1 / (2 * l_V) * cormat_inv %*% mat_sig_eigvecs_aug %*% lambdas
  w_star <- -1 / (2 * l_V) * mat_eigvecs %*% diag(1 / eigvals) %*% t(mat_eigvecs) %*% mat_sig_eigvecs_aug %*% lambdas
  #sum(w_star)
  ew_star <- exp(w_star)
  ew_star_normed <- ew_star / sum(ew_star)
  print(round(sum(last_ewStarNmd - ew_star_normed)^2, 3))
  last_ewStarNmd <- ew_star_normed

  V_check <- t(w_star) %*% cormat %*% w_star - V_tol_implicit
  
  #print(V_tol_implicit - V_check)
  #print(lambdas)
  
  NR_vec[i] <- NR_star
  V_vec[i] <- V_tol_implicit
  lC_vec[i] <- l_C
  lV_vec[i] <- l_V
  list_wStar[[i]] <- w_star
  list_wStar_eNormd[[i]] <- ew_star_normed
  list_lambdas[[i]] <- lambdas[-length(lambdas)]
}

df_plot <- data.frame(V = V_vec, NR = NR_vec, lC = lC_vec, lV = lV_vec)
gg <- ggplot(df_plot, aes(x = V, y = NR, color = r_lev))
gg <- gg + geom_point()
gg




df_lStack <- data.frame(V = NA, NR = NA, id = NA, l = NA)
for(i in 1:nrow(df_plot)){df_lStack <- rbind(df_lStack, data.frame(V = df_plot$V[i], NR = df_plot$NR[i], id = as.character(1:n_sigs), l = c(list_lambdas[[i]])))}

gg <- ggplot(df_lStack, aes(x = V, y = l)) + geom_area(aes(fill = id))
#gg <- gg + geom_vline(xintercept = df$Risk[ind_opt], color = "green", lwd = 2)
gg <- gg + labs(x = "Potfolio Risk", y = "lambdas")
#gg <- gg + theme(legend.position = "none")
gg






df_wStack <- data.frame(V = NA, NR = NA, Security = NA, Type = NA, w = NA, ew_normd = NA)
for(i in 1:nrow(df_plot)){df_wStack <- rbind(df_wStack, data.frame(V = df_plot$V[i], NR = df_plot$NR[i], Security = row.names(mat_sig_eigvecs), Type = group_vec, w = c(list_wStar[[i]]), ew_normd = c(list_wStar_eNormd[[i]])))}
#for(i in 1:nrow(df)){df_wStack <- rbind(df_wStack, data.frame(Risk = df$Risk[i], EUr = df$EUr[i], Project = c(1:n_proj), w = c(w_norm[[i]])))}
#df_wStack <- df_wStack %>% group_by()
df_wStack <- df_wStack[-1, ]

# #df_wStack$Security <- as.character(df_wStack$Security)
# #df_wStack$w <- df_wStack$w / df$C[ind]
# #ind_opt <- which(df$EUr == max(df$EUr))
# df_wStack$ew <- exp(df_wStack$w)
# df_wStack$Type <- factor(df_wStack$Type)
# xx <- df_wStack$Type
# df_wStack$Security <- factor(df_wStack$Security, levels = unique(df_wStack$Security[order(xx)]))
# 
# 
# 
# df_wStack$ew <- factor(df_wStack$ew,
#                        levels = unique(df_wStack$Type[order(xx)]),
#                        ordered = T)

gg <- ggplot(df_wStack, aes(x = V, y = w)) + geom_area(aes(fill = Security))
#gg <- gg + geom_vline(xintercept = df$Risk[ind_opt], color = "green", lwd = 2)
gg <- gg + labs(x = "Potfolio Risk", y = "Project Budget Weights")
gg <- gg + theme(legend.position = "none")
gg






```







Little or no care is taken, however, to address the tradeoffs that exist between investments in each of these thematic areas. It is well known, for example, that agriculture is often detrimental to the environment. This implies a tradeoff between the food security and environmental objectives. Economic growth, in its turn, is inversely related to both agricultural and environmental objectives. In many parts of the world, there is also a longstanding tradeoff between economic growth and economic equality. Investments in one thematic area can thus offset returns to investments in other thematic areas.

Moreover, conventional

### I.ii Proposed solution: a PCA approach

In this concept note, I propose a rigorous, precise method for identifying and quantifying tradeoffs and synergies between strategic objectives (SOs). The method is based on principle components analysis (PCA) of a large dataset of development indicators spanning the usual thematic areas. (For a good overview of PCA, see Abdi & Williams (2010).) A variant of this approach has been applied in the analysis of financial market time series (Gopikrishnan et al., 2001). Here I enhance such precedents by also leveraging a rigorous signal selecting technique developed in the study of physical systems (Dehesa et al., 1983).


```{r, echo=FALSE}
setwd("D:/OneDrive - CGIAR/Documents")
#options(warn = -1); options(scipen = 999)
#-------------------------------------------------------------
library(plyr)
library(tidyverse)
library(ggplot2)
library(zoo)
library(FactoMineR)
library(factoextra)
library(Hmisc)
library(corrplot)
#library(PerformanceAnalytics)




#-------------------------------------------------------------
remove_countries <- c("São Tomé and Principe", "Micronesia, Fed. Sts.")
WDI_country_classification <- read.csv("WDICountry.csv", stringsAsFactors = F)
Low_income_countries <- unique(WDI_country_classification$Table.Name[which(WDI_country_classification$Income.Group == "Low income")])

Lower_middle_income_countries <- unique(WDI_country_classification$Table.Name[which(WDI_country_classification$Income.Group == "Lower middle income")])
Upper_middle_income_countries <- unique(WDI_country_classification$Table.Name[which(WDI_country_classification$Income.Group == "Upper middle income")])

WDI_raw <- read.csv("WDIData.csv", stringsAsFactors = F)
WDI_raw$Country.Code <- NULL
WDI_raw$Indicator.Code <- NULL
WDI_raw$X <- NULL
colnames(WDI_raw)[1:2] <- c("Country", "Indicator")
WDI_raw$Country <- as.character(WDI_raw$Country)
WDI_raw$Indicator <- as.character(WDI_raw$Indicator)
#unique(WDI_raw$Country)
#unique(WDI_raw$Indicator)
unique(WDI_raw$Indicator[grep("basic", WDI_raw$Indicator, ignore.case = T)])
colnames(WDI_raw)[3:ncol(WDI_raw)] <- as.character(c(1960:2018))
WDI_long <- WDI_raw %>% gather(Year, Value, `1960`:`2018`)
#unique(WDI_raw$Country)
WDI_long <- as.data.frame(WDI_long %>% group_by(Year, Indicator) %>% mutate(world_mu = mean(Value, na.rm = T)))
ind_worldGini <- which(WDI_long$Country == "World" & WDI_long$Indicator == "GINI index (World Bank estimate)")
WDI_long$Value[ind_worldGini] <- WDI_long$world_mu[ind_worldGini]
ind_worldIncomeBottom <- which(WDI_long$Country == "World" & WDI_long$Indicator == "Income share held by lowest 20%")
WDI_long$Value[ind_worldIncomeBottom] <- WDI_long$world_mu[ind_worldIncomeBottom]
WDI_long$world_mu <- NULL
WDI_long <- as.data.frame(WDI_long %>% group_by(Year, Indicator) %>% mutate(world_sum = sum(Value, na.rm = T)))
ind_worldBatDeaths <- which(WDI_long$Country == "World" & WDI_long$Indicator == "Battle-related deaths (number of people)")
WDI_long$Value[ind_worldBatDeaths] <- WDI_long$world_sum[ind_worldBatDeaths]
WDI_long$world_sum <- NULL
WDI_long$Value[which(is.nan(WDI_long$Value))] <- NA
#unique(WDI_long$Indicator)
#unique(WDI_raw$Indicator)[grep("Average", unique(WDI_raw$Indicator))]
#-------------------------------------------------------------

```



```{r, fig.width=10, fig.height=4, fig.align='center', echo = FALSE}

environmental_indicators <- c("CO2 emissions (metric tons per capita)", 
                              #"Combustible renewables and waste (% of total energy)",
                              "CO2 intensity (kg per kg of oil equivalent energy use)",
                              "Forest area (% of land area)",
                              "GDP per unit of energy use (PPP $ per kg of oil equivalent)",
                              "Energy intensity level of primary energy (MJ/$2011 PPP GDP)",
                              "Renewable energy consumption (% of total final energy consumption)",
                              "Agricultural methane emissions (thousand metric tons of CO2 equivalent)",
                              "Agricultural nitrous oxide emissions (thousand metric tons of CO2 equivalent)",
                              "Methane emissions in energy sector (thousand metric tons of CO2 equivalent)",
                              "Nitrous oxide emissions in energy sector (thousand metric tons of CO2 equivalent)",
                              "Fertilizer consumption (kilograms per hectare of arable land)",
                              "Fertilizer consumption (% of fertilizer production)",
                              "Adjusted savings: net forest depletion (% of GNI)",
                              "Adjusted savings: mineral depletion (% of GNI)",
                              "Adjusted savings: energy depletion (% of GNI)",
                              "Level of water stress: freshwater withdrawal as a proportion of available freshwater resources",
                              "Access to clean fuels and technologies for cooking (% of population)",
                              "Renewable internal freshwater resources per capita (cubic meters)"
                              #"Water productivity, total (constant 2010 US$ GDP per cubic meter of total freshwater withdrawal)"
)
#-------------------------------------------------------------
food_sec_indicators <- c("Agricultural land (% of land area)",
                         "Land under cereal production (hectares)",
                         "Prevalence of undernourishment (% of population)",
                         "Food imports (% of merchandise imports)",
                         "Agriculture, forestry, and fishing, value added per worker (constant 2010 US$)",
                         "Agriculture, value added per worker (constant 2010 US$)",
                         "Agriculture, forestry, and fishing, value added (% of GDP)",
                         #"Agriculture, forestry, and fishing, value added (annual % growth)",
                         "Food, beverages and tobacco (% of value added in manufacturing)"
)

economic_growth_indicators <- c(
  "Oil rents (% of GDP)",
  "Coal rents (% of GDP)",
  "Forest rents (% of GDP)",
  "Natural gas rents (% of GDP)",
  #"Total natural resources rents (% of GDP)",
  "Mineral rents (% of GDP)",
  #"Foreign direct investment, net (BoP, current US$)",
  "Foreign direct investment, net inflows (BoP, current US$)",
  #"Foreign direct investment, net inflows (% of GDP)",
  #"Export value index (2000 = 100)",
  #"Import value index (2000 = 100)",
  "GDP per capita (current US$)",
  "Net ODA received per capita (current US$)",
  "Trade (% of GDP)",
  #"GDP growth (annual %)",
  #"GDP per capita growth (annual %)",
  "Industry (including construction), value added (% of GDP)",
  #"Industry (including construction), value added (annual % growth)",
  "Manufacturing, value added (% of GDP)",
  #"Manufacturing, value added (annual % growth)",
  "Machinery and transport equipment (% of value added in manufacturing)",
  "Services, value added (% of GDP)",
  #"Services, value added (annual % growth)",
  "Trade in services (% of GDP)",
  #"Exports of goods and services (annual % growth)",
  #"Imports of goods and services (annual % growth)",
  #"Medium and high-tech Industry (including construction) (% manufacturing value added)",
  #"Gross capital formation (annual % growth)",
  #"Gross fixed capital formation (annual % growth)",
  #"Final consumption expenditure (annual % growth)",
  "Final consumption expenditure (constant 2010 US$)",
  "Employment in agriculture (% of total employment) (modeled ILO estimate)",
  "Employment in industry (% of total employment) (modeled ILO estimate)",
  "Employment in services (% of total employment) (modeled ILO estimate)",
  "Labor force participation rate, total (% of total population ages 15+) (modeled ILO estimate)",
  #"Unemployment, total (% of total labor force) (modeled ILO estimate)",
  "Industry, value added per worker (constant 2010 US$)",
  "Industry (including construction), value added per worker (constant 2010 US$)",
  "Services, value added per worker (constant 2010 US$)"
)
#-------------------------------------------------------------
peaceHRights_indicators <- c("Military expenditure (% of GDP)",
                             "Ratio of female to male labor force participation rate (%) (modeled ILO estimate)",
                             "Refugee population by country or territory of origin",
                             "Internally displaced persons, new displacement associated with conflict and violence (number of cases)",
                             "Internally displaced persons, total displaced by conflict and violence (number of people)",
                             "Battle-related deaths (number of people)",
                             "Literacy rate, youth (ages 15-24), gender parity index (GPI)",
                             "School enrollment, primary (gross), gender parity index (GPI)",
                             "School enrollment, primary and secondary (gross), gender parity index (GPI)",
                             "School enrollment, secondary (gross), gender parity index (GPI)",
                             "School enrollment, tertiary (gross), gender parity index (GPI)"  
)
#-------------------------------------------------------------
economic_equality_indicators <- c("Consumer price index (2010 = 100)",
                                  "Income share held by lowest 10%",
                                  "Income share held by lowest 20%",
                                  #"GINI index (World Bank estimate)",
                                  "Risk premium on lending (lending rate minus treasury bill rate, %)",
                                  #"Poverty gap at $1.90 a day (2011 PPP) (%)",
                                  "Poverty headcount ratio at $1.90 a day (2011 PPP) (% of population)",
                                  "Number of people pushed below the $1.90 ($ 2011 PPP) poverty line by out-of-pocket health care expenditure",
                                  "Number of people pushed below the $3.10 ($ 2011 PPP) poverty line by out-of-pocket health care expenditure",
                                  "Number of people spending more than 10% of household consumption or income on out-of-pocket health care expenditure",
                                  "Number of people spending more than 25% of household consumption or income on out-of-pocket health care expenditure",
                                  "Mortality rate attributed to unsafe water, unsafe sanitation and lack of hygiene (per 100,000 population)",
                                  "People using at least basic sanitation services (% of population)",
                                  "People using at least basic sanitation services, rural (% of rural population)",
                                  "People using at least basic sanitation services, urban (% of urban population)",
                                  "People using safely managed sanitation services (% of population)",
                                  "People using safely managed sanitation services, rural (% of rural population)",
                                  "People using safely managed sanitation services, urban (% of urban population)",
                                  "People using at least basic drinking water services (% of population)",
                                  "People using at least basic drinking water services, rural (% of rural population)",
                                  "People using at least basic drinking water services, urban (% of urban population)",
                                  "Labor force with basic education, female (% of female working-age population with basic education)",
                                  "Labor force with basic education, male (% of male working-age population with basic education)"
)
#-------------------------------------------------------------
infrastructure_indicators <- c(#"Access to electricity (% of population)",
  "Access to electricity, urban (% of urban population)",
  "Access to electricity, rural (% of rural population)",
  "Air transport, freight (million ton-km)",
  "Air transport, passengers carried",
  "Railways, goods transported (million ton-km)",
  "Railways, passengers carried (million passenger-km)"
  #"Mobile cellular subscriptions (per 100 people)"
  #"Individuals using the Internet (% of population)"
)
#-------------------------------------------------------------
healthPop_indicators <- c("Mortality rate, under-5 (per 1,000 live births)",
                          #"Incidence of HIV (% of uninfected population ages 15-49)",
                          "Life expectancy at birth, total (years)",
                          # "Life expectancy at birth, male (years)",
                          # "Life expectancy at birth, female (years)"
                          "Prevalence of HIV, total (% of population ages 15-49)",
                          #"Birth rate, crude (per 1,000 people)",
                          #"Death rate, crude (per 1,000 people)",
                          "Urban population (% of total population)",
                          "Rural population (% of total population)",
                          #"Urban population growth (annual %)",
                          #"Population growth (annual %)",
                          #"Population ages 0-14, total",
                          #"Population ages 0-14 (% of total)",
                          #"Population ages 15-64, total",
                          #"Population ages 15-64 (% of total)",
                          #"Population ages 65 and above, total",
                          #"Population ages 65 and above (% of total)",
                          "Population density (people per sq. km of land area)",
                          "Population growth (annual %)",
                          "Physicians (per 1,000 people)",
                          # "Population, total",
                          #"Age dependency ratio, young (% of working-age population)",
                          #"Age dependency ratio, old (% of working-age population)",
                          "Age dependency ratio (% of working-age population)",
                          "Adolescent fertility rate (births per 1,000 women ages 15-19)"
                          
)
#-------------------------------------------------------------
educ_indicators <- c("Government expenditure on education, total (% of GDP)",
                     "School enrollment, primary (% gross)",
                     "School enrollment, secondary (% gross)",
                     "School enrollment, tertiary (% gross)",
                     #"Adjusted savings: education expenditure (current US$)",
                     "Adjusted savings: education expenditure (% of GNI)",
                     "Expenditure on primary education (% of government expenditure on education)",
                     "Expenditure on secondary education (% of government expenditure on education)",
                     "Expenditure on tertiary education (% of government expenditure on education)",
                     "Government expenditure on education, total (% of government expenditure)",
                     "Literacy rate, adult total (% of people ages 15 and above)",
                     "Literacy rate, youth total (% of people ages 15-24)"
)
#-------------------------------------------------------------
indicator_vec <- c(healthPop_indicators, food_sec_indicators, educ_indicators,
                   economic_growth_indicators, economic_equality_indicators,
                   environmental_indicators, peaceHRights_indicators,
                   infrastructure_indicators)
list_tsTypes <- list(healthPop_indicators, food_sec_indicators, educ_indicators,
                     economic_growth_indicators, economic_equality_indicators,
                     environmental_indicators, peaceHRights_indicators,
                     infrastructure_indicators)
tsType_names <- c("Health/Population", "Food Security", "Education",
                  "Economic Growth", "Economic Equality",
                  "Environmental Sustainability", "Peace and Human Rights", "Infrastructure")
names(list_tsTypes) <- tsType_names
#-------------------------------------------------------------
#"Least developed countries: UN classification"
#"Sub-Saharan Africa (excluding high income)"
#"Lower middle income"
these_countries <- "World"
#-------------------------------------------------------------
df_WDI <- subset(WDI_long, Country %in% c(these_countries))
df_WDI <- subset(df_WDI, Indicator %in% indicator_vec)
df_WDI <- df_WDI %>% spread(Indicator, Value)
df_WDI$Year <- as.integer(df_WDI$Year)
df_WDI <- subset(df_WDI, Year >= 1990)
df_WDI <- subset(df_WDI, Year <= 2016)
#df_WDI$`Individuals using the Internet (% of population)`[which(df_WDI$Year < 1994)] <- 0
#-------------------------------------------------------------
year_vec <- df_WDI$Year
df_WDI <- df_WDI[, -c(1, 2)]
out <- apply(df_WDI, 2, function(x) length(which(is.na(x))))
#table(out)
ind_rm <- which(as.numeric(out) > 10)
#length(ind_rm)
df_WDI <- df_WDI[, -ind_rm]
#ncol(df_WDI)
ind_rp <- which(is.na(df_WDI[1, ]))
if(length(ind_rp) != 0){
  for(i in 1:length(ind_rp)){
    df_WDI[1, ind_rp[i]] <- mean(df_WDI[, ind_rp[i]], na.rm = T)
  }
}
ind_rp <- which(is.na(df_WDI[nrow(df_WDI), ]))
for(i in 1:length(ind_rp)){
  df_WDI[nrow(df_WDI), ind_rp[i]] <- mean(df_WDI[, ind_rp[i]], na.rm = T)
}

#df_WDI <- as.data.frame(na.approx(df_WDI[, -c(1, 2)]))
df_WDI <- as.data.frame(na.approx(df_WDI))
#class(df_WDI)
out <- apply(df_WDI, 2, function(x) length(which(is.na(x))))
table(out)
#which(as.numeric(out) > 0)
#colnames(df_WDI)[which(as.numeric(out) > 0)]
#mat_zWDI <- scale(df_WDI)
#mat_in <- diff(as.matrix(log(df_WDI)))
mat_in <- diff(as.matrix(df_WDI)) / as.matrix(df_WDI[-nrow(df_WDI), ])
row.names(mat_in) <- year_vec[-1]
# library(tidyquant)
# ema_per <- 2
# mat_in <- apply(df_WDI, 2, function(x) x - EMA(x, ema_per))
# row.names(mat_in) <- year_vec
# mat_in <- mat_in[-c(1:(ema_per - 1)), ]
# mat_in[is.nan(mat_in)] <- 0
# mat_in[is.infinite(mat_in)] <- 0
#-----------------------------------------------------------
df_plot <- as.data.frame(mat_in)
df_plot$Year <- year_vec[-1]
df_plot <- df_plot %>% gather_("Indicator", "Value", colnames(df_WDI))
df_plot$Type <- NA
df_plot$Type[which(df_plot$Indicator %in% healthPop_indicators)] <- "Health/Population"
df_plot$Type[which(df_plot$Indicator %in% economic_equality_indicators)] <- "Economic Equality"
df_plot$Type[which(df_plot$Indicator %in% educ_indicators)] <- "Education"
df_plot$Type[which(df_plot$Indicator %in% economic_growth_indicators)] <- "Economic Growth"
df_plot$Type[which(df_plot$Indicator %in% environmental_indicators)] <- "Environmental Sustainability"
df_plot$Type[which(df_plot$Indicator %in% food_sec_indicators)] <- "Food Security"
df_plot$Type[which(df_plot$Indicator %in% infrastructure_indicators)] <- "Infrastructure"
df_plot$Type[which(df_plot$Indicator %in% peaceHRights_indicators)] <- "Peace and Human Rights"
#------------------------------------------------------------
# gg <- ggplot(df_plot, aes(x = Year, y = Value, group = Indicator, color = Indicator))
# gg <- gg + geom_line()
# gg <- gg + facet_wrap(~ Type, nrow = 3, scales = "free")
# gg <- gg + theme(legend.position = "none")
# gg
#------------------------------------------------------------
this_type <- "Health/Population"
df_plot2 <- subset(df_plot, Type == this_type)
gg <- ggplot(df_plot2, aes(x = Year, y = Value, group = Indicator, color = Indicator))
gg <- gg + geom_line(lwd = 1.1)
gg <- gg + geom_point(size = 2)
gg <- gg + labs(title = this_type)
gg_health <- gg
gg
this_type <- "Education"
df_plot2 <- subset(df_plot, Type == this_type)
gg <- ggplot(df_plot2, aes(x = Year, y = Value, group = Indicator, color = Indicator))
gg <- gg + geom_line(lwd = 1.1)
gg <- gg + geom_point(size = 2)
gg <- gg + labs(title = this_type)
gg_educ <- gg
gg
this_type <- "Economic Growth"
df_plot2 <- subset(df_plot, Type == this_type)
gg <- ggplot(df_plot2, aes(x = Year, y = Value, group = Indicator, color = Indicator))
gg <- gg + geom_line(lwd = 1.1)
gg <- gg + geom_point(size = 2)
gg <- gg + labs(title = this_type)
gg_econ <- gg
gg
this_type <- "Economic Equality"
df_plot2 <- subset(df_plot, Type == this_type)
gg <- ggplot(df_plot2, aes(x = Year, y = Value, group = Indicator, color = Indicator))
gg <- gg + geom_line(lwd = 1.1)
gg <- gg + geom_point(size = 2)
gg <- gg + labs(title = this_type)
gg_employ <- gg
gg
this_type <- "Environmental Sustainability"
df_plot2 <- subset(df_plot, Type == this_type)
gg <- ggplot(df_plot2, aes(x = Year, y = Value, group = Indicator, color = Indicator))
gg <- gg + geom_line(lwd = 1.1)
gg <- gg + geom_point(size = 2)
gg <- gg + labs(title = this_type)
gg_environ <- gg
gg
this_type <- "Food Security"
df_plot2 <- subset(df_plot, Type == this_type)
gg <- ggplot(df_plot2, aes(x = Year, y = Value, group = Indicator, color = Indicator))
gg <- gg + geom_line(lwd = 1.1)
gg <- gg + geom_point(size = 2)
gg <- gg + labs(title = this_type)
gg_pop <- gg
gg
this_type <- "Infrastructure"
df_plot2 <- subset(df_plot, Type == this_type)
gg <- ggplot(df_plot2, aes(x = Year, y = Value, group = Indicator, color = Indicator))
gg <- gg + geom_line(lwd = 1.1)
gg <- gg + geom_point(size = 2)
gg <- gg + labs(title = this_type)
gg_infrastr <- gg
gg
this_type <- "Peace and Human Rights"
df_plot2 <- subset(df_plot, Type == this_type)
gg <- ggplot(df_plot2, aes(x = Year, y = Value, group = Indicator, color = Indicator))
gg <- gg + geom_line(lwd = 1.1)
gg <- gg + geom_point(size = 2)
gg <- gg + labs(title = this_type)
gg_infrastr <- gg
gg
```

```{r, fig.width=15, fig.height=12, fig.align='center', echo=FALSE}
#------------------------------------------------------------

df_sigs <- Signals_from_noise(mat_in, list_tsTypes = list_tsTypes,
                              tsType_names = tsType_names,
                              pca_var_plot = T,
                              pca_ind_plot = T,
                              eigenvalue_density_plot = T,
                              yearly = T)


colMeans(df_sigs[, -1])
sig_vec <- apply(df_sigs[, -1], 2, sd)
covmat <- diag(sig_vec) %*% cor(df_sigs[, -1]) %*% diag(sig_vec)
print(covmat)

```


```{r, fig.width=12, fig.height=4, fig.align='center', echo=FALSE}

#------------------------------------------------------------
df_plot1 <- data.frame(Year = as.integer(names(ts_avg)), ts_avg)
df_plot2 <- data.frame(Year = as.integer(names(ts_avg)), mat_signal_ts)
signal_id <- paste("Signal", c(1:n_signals))
colnames(df_plot2)[2:(n_signals + 1)] <- signal_id
gathercols <- signal_id
df_plot2 <- df_plot2 %>% gather_("Signal", "Value", gathercols)
gg <- ggplot()
gg <- gg + geom_line(data = df_plot1, aes(x = Year, y = ts_avg), color = "orange", lwd = 1.2)
gg <- gg + geom_line(data = df_plot2, aes(x = Year, y = Value))
gg <- gg + facet_wrap(~ Signal, nrow = 1)
gg <- gg + theme(axis.title.y = element_blank())
gg

```

```{r, echo=FALSE}

apply(mat_signal_ts, 2, mean)
mat_x <- mat_signal_ts - ts_avg
mu_r <- apply(mat_x, 2, mean)
mu_r
```
